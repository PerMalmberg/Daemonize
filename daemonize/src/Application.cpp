// Copyright (c) 2016 Per Malmberg
// Licensed under MIT, see LICENSE file.
// Give credit where credit is due.

#include <iostream>
#include "daemonize/Application.h"

using namespace daemonize;

Application* Application::mySelf;

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////
int Application::Run()
{
	SetupSignalHandlers();
	// Simply run the main method
	return Main();
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////
int Application::RunAsDaemon()
{
	int result = 1;

	Daemon::ProcessIdentity identity;
	bool res = myDaemonizer.Daemonize( myWorkingDirectory, identity );

	if( res )
	{
		if( identity == Daemon::ProcessIdentity::DAEMON_PROCESS )
		{
			SetupSignalHandlers();
			result = Main(); // Call the main method
		}
		else
		{
			// Original or intermediate process
			result = 0;
		}
	}

	return result;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////
Application::Application( const std::string& workingDirectory )
		: myWorkingDirectory( workingDirectory )
{
	// Set the static reference to ourselves.
	mySelf = this;
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////
void Application::SetupSignalHandlers()
{
	struct sigaction sa;
	sa.sa_handler = &HandleSignal;
	sa.sa_flags = SA_RESTART;
	sigfillset( &sa.sa_mask );

	// Add handles for wanted signals
	for( auto signal : myInterceptedSignals)
	{
		sigaction( signal, &sa, nullptr );
	}
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////
void Application::HandleSignal( int signal )
{
	mySelf->SetSignal( signal );
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////
void Application::SetSignal( int signal )
{
	if( ValidateSignal( signal ) )
	{
		mySignals[signal].store( true );
	}
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////
bool Application::ValidateSignal( int signal ) const
{
	return signal > 0 && signal < sizeof( mySignals );
}

///////////////////////////////////////////////////////////////////////////////
//
//
///////////////////////////////////////////////////////////////////////////////
bool Application::PollSignal( int signal )
{
	bool result;

	if( ValidateSignal(signal))
	{
		result = mySignals[signal];
		mySignals[signal].store( false );
	}
	else {
		result = false;
	}

	return result;
}

